# Database Migrations with Alembic ğŸ› ï¸ğŸ“š

## Project Overview  
Previously, we applied changes to the database using the lifespan event created in Chapter 5.  
This method allowed us to create the table each time our server started, which was helpful during development.  
However, in a production environment, we need a proper database migration system to migrate changes to our database schema without restarting our server.  

To achieve this, we will use **Alembic**, a database migration tool for use with **SQLAlchemy**.  
Since we are using **SQLModel**, which is based on SQLAlchemy, Alembic will be very useful.  

Let's begin by installing Alembic in our virtual environment using pip:  

## Installing Alembic  
```bash
(env) $ pip install alembic
```

To confirm that Alembic has been installed, run the following command:  
```bash
(env) $ alembic --version
```

Expected output:  
```text
alembic 1.13.1
```

## Creating the Migration Environment  
```bash
(env) $ alembic init -t async migrations
```

Expected output:  
```text
Creating directory '/path/to/project/migrations' ...  done
Creating directory '/path/to/project/migrations/versions' ...  done
Generating /path/to/project/migrations/script.py.mako ...  done
Generating /path/to/project/migrations/env.py ...  done
Generating /path/to/project/alembic.ini ...  done
Generating /path/to/project/migrations/README ...  done
Please edit configuration/connection/logging settings in '/path/to/project/alembic.ini' before proceeding.
```

The above command creates a migration environment.  
The `migrations/` folder and the `alembic.ini` file are generated by Alembic and form the migration environment.  
We used the `-t` option to specify the template (`async`) because our project uses an async DBAPI.  

<br>

### Current Project Structure with Migration Environment  
```
â”œâ”€â”€ alembic.ini
â”œâ”€â”€ migrations
â”‚   â”œâ”€â”€ env.py
â”‚   â”œâ”€â”€ README
â”‚   â”œâ”€â”€ script.py.mako
â”‚   â””â”€â”€ versions
â”œâ”€â”€ README.md
â”œâ”€â”€ requirements.txt
â””â”€â”€ src
    â”œâ”€â”€ auth
    â”‚   â”œâ”€â”€ __init__.py
    â”‚   â”œâ”€â”€ models.py
    â”œâ”€â”€ books
    â”‚   â”œâ”€â”€ book_data.py
    â”‚   â”œâ”€â”€ __init__.py
    â”‚   â”œâ”€â”€ models.py
    â”‚   â”œâ”€â”€ routes.py
    â”‚   â”œâ”€â”€ schemas.py
    â”‚   â””â”€â”€ service.py
    â”œâ”€â”€ config.py
    â”œâ”€â”€ db
    â”‚   â”œâ”€â”€ __init__.py
    â”‚   â””â”€â”€ main.py
    â””â”€â”€ __init__.py
```

<br>

The `migrations/` directory contains:  
- **versions/**: Python scripts for each migration  
- **env.py**: Entry point for Alembic commands  
- **README**: Description of the migration environment  
- **script.py.mako**: Template for creating new migration scripts  

The `alembic.ini` file contains configurations for Alembic to interact with the database.

<br>

## Setting up SQLModel with Alembic  
We edit `migrations/env.py` as follows:

```python
import asyncio
from logging.config import fileConfig

from sqlalchemy import pool
from sqlalchemy.engine import Connection
from sqlalchemy.ext.asyncio import async_engine_from_config

from alembic import context
from sqlmodel import SQLModel
from src.config import Config


database_url = Config.DATABASE_URL

config = context.config
config.set_main_option("sqlalchemy.url", database_url)

if config.config_file_name is not None:
    fileConfig(config.config_file_name)

target_metadata = SQLModel.metadata
...
```

This setup ensures Alembic can track changes from the SQLModel models.  

Next, we also edit `migrations/script.py.mako` to import SQLModel:

```python
"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
import sqlmodel  # ADD THIS
...
```

<br>

## Creating Our First Migration  

```bash
(env) $ alembic revision --autogenerate -m "init"
```

Expected output:  
```text
INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.
INFO  [alembic.runtime.migration] Will assume transactional DDL.
INFO  [alembic.autogenerate.compare] Detected added table 'user_accounts'
Generating /path/to/project/migrations/versions/8cf8276d5f3c_init.py ...  done
```

Generated file `migrations/versions/8cf8276d5f3c_init.py`:

```python
"""init

Revision ID: 8cf8276d5f3c
Revises: 
Create Date: 2024-05-21 19:27:53.577277

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
import sqlmodel
from sqlalchemy.dialects import postgresql

revision: str = '8cf8276d5f3c'
down_revision: Union[str, None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None

def upgrade() -> None:
    op.create_table(
        'user_accounts',
        sa.Column('uid', sa.UUID(), nullable=False),
        sa.Column('username', sqlmodel.sql.sqltypes.AutoString(), nullable=False),
        sa.Column('first_name', sqlmodel.sql.sqltypes.AutoString(), nullable=True),
        sa.Column('last_name', sqlmodel.sql.sqltypes.AutoString(), nullable=True),
        sa.Column('is_verified', sa.Boolean(), nullable=False),
        sa.Column('email', sqlmodel.sql.sqltypes.AutoString(), nullable=False),
        sa.Column('password_hash', sqlmodel.sql.sqltypes.AutoString(), nullable=False),
        sa.Column('created_at', postgresql.TIMESTAMP(), nullable=True),
        sa.PrimaryKeyConstraint('uid'),
        sa.UniqueConstraint('uid')
    )

def downgrade() -> None:
    op.drop_table('user_accounts')
```

<br>

## Applying the Migration  

```bash
(env) $ alembic upgrade head
```

Expected output:  
```text
INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.
INFO  [alembic.runtime.migration] Will assume transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade  -> 8cf8276d5f3c, init
```

Connect to PostgreSQL and verify:

```bash
(env) $ psql --username=<your-username> --dbname=<your-db>
```

Example:
```bash
(env) $ psql --username=jod35 --dbname=books
```

Check tables:
```sql
books=# \dt
```

Expected result:
```text
 Schema |      Name       | Type  | Owner 
--------+-----------------+-------+-------
 public | alembic_version | table | jod35
 public | books           | table | jod35
 public | user_accounts   | table | jod35
(3 rows)
```

Check structure of `alembic_version`:
```sql
books=# \d alembic_version
```

```text
Column      | Type                  | Collation | Nullable | Default 
------------+-----------------------+-----------+----------+---------
version_num | character varying(32)  |           | not null |
Indexes:
    "alembic_version_pkc" PRIMARY KEY, btree (version_num)
```

Check structure of `user_accounts`:
```sql
books=# \d user_accounts
```

```text
Column        | Type                        | Collation | Nullable | Default 
--------------+-----------------------------+-----------+----------+---------
uid           | uuid                        |           | not null |
username      | character varying           |           | not null |
first_name    | character varying           |           |          |
last_name     | character varying           |           |          |
is_verified   | boolean                     |           | not null |
email         | character varying           |           | not null |
password_hash | character varying           |           | not null |
created_at    | timestamp without time zone |           |          |
Indexes:
    "user_accounts_pkey" PRIMARY KEY, btree (uid)
```

<br>

# Conclusion  
In this chapter, we have created a simple database model to enable us to manage user accounts in our application.  
We introduced **Alembic**, a database migration tool that works with **SQLAlchemy models**, enabling us to easily introduce changes to the database structure without losing existing data.

---
